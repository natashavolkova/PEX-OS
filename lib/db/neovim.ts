// ============================================================================
// ATHENAPEX - NEOVIM CONFIG DATA ACCESS
// CRUD operations for Neovim configurations
// ============================================================================

import prisma from '@/lib/prisma';

export type NeovimBase = 'lazyvim' | 'astronvim' | 'custom';

export interface CreateNeovimConfigInput {
    name: string;
    base: NeovimBase;
    lspConfigs: string[];
    plugins: string[];
    content: string;
}

export interface UpdateNeovimConfigInput {
    name?: string;
    base?: NeovimBase;
    lspConfigs?: string[];
    plugins?: string[];
    content?: string;
}

// --- CREATE ---
export async function createConfig(userId: string, data: CreateNeovimConfigInput) {
    return prisma.neovimConfig.create({
        data: {
            userId,
            ...data,
        },
    });
}

// --- READ ALL ---
export async function getConfigs(
    userId: string,
    options?: {
        base?: NeovimBase;
        search?: string;
        limit?: number;
        offset?: number;
    }
) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: any = { userId };

    if (options?.base) {
        where.base = options.base;
    }

    if (options?.search) {
        where.name = { contains: options.search, mode: 'insensitive' };
    }

    const [configs, total] = await Promise.all([
        prisma.neovimConfig.findMany({
            where,
            orderBy: { updatedAt: 'desc' },
            take: options?.limit ?? 50,
            skip: options?.offset ?? 0,
        }),
        prisma.neovimConfig.count({ where }),
    ]);

    return { configs, total };
}


// --- READ ONE ---
export async function getConfigById(id: string) {
    return prisma.neovimConfig.findUnique({
        where: { id },
    });
}

// --- UPDATE ---
export async function updateConfig(id: string, data: UpdateNeovimConfigInput) {
    return prisma.neovimConfig.update({
        where: { id },
        data,
    });
}

// --- DELETE ---
export async function deleteConfig(id: string) {
    return prisma.neovimConfig.delete({
        where: { id },
    });
}

// --- GENERATE CONFIG CONTENT ---
export function generateConfigContent(
    base: NeovimBase,
    lspConfigs: string[],
    plugins: string[]
): string {
    const baseConfigs: Record<NeovimBase, string> = {
        lazyvim: `-- LazyVim Configuration
-- Generated by AthenaPeX

return {
  spec = {
    { "LazyVim/LazyVim", import = "lazyvim.plugins" },
`,
        astronvim: `-- AstroNvim Configuration
-- Generated by AthenaPeX

return {
  colorscheme = "catppuccin",
  lsp = {
    servers = {
`,
        custom: `-- Custom Neovim Configuration
-- Generated by AthenaPeX

vim.g.mapleader = " "
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.expandtab = true
vim.opt.shiftwidth = 2
vim.opt.tabstop = 2

-- Plugin Manager (lazy.nvim)
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git", "clone", "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

require("lazy").setup({
`,
    };

    let content = baseConfigs[base];

    // Add LSP configs
    if (lspConfigs.length > 0) {
        content += `\n  -- LSP Servers\n`;
        lspConfigs.forEach((lsp) => {
            content += `  -- ${lsp}\n`;
        });
    }

    // Add plugins
    if (plugins.length > 0) {
        content += `\n  -- Plugins\n`;
        plugins.forEach((plugin) => {
            content += `  { "${plugin}" },\n`;
        });
    }

    content += `\n})\n`;

    return content;
}
